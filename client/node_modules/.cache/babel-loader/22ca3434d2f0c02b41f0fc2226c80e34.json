{"ast":null,"code":"/**\n * jsTPS_Transaction\n *\n * This provides the basic structure for a transaction class. Note to use\n * jsTPS one should create objects that define these two methods, doTransaction\n * and undoTransaction, which will update the application state accordingly.\n *\n * @author THE McKilla Gorilla (accept no imposters)\n * @version 1.0\n */\nexport class jsTPS_Transaction {\n  /**\n   * This method is called by jTPS when a transaction is executed.\n   */\n  doTransaction() {\n    console.log(\"doTransaction - MISSING IMPLEMENTATION\");\n  }\n  /**\n   * This method is called by jTPS when a transaction is undone.\n   */\n\n\n  undoTransaction() {\n    console.log(\"undoTransaction - MISSING IMPLEMENTATION\");\n  }\n\n}\n/**\n * jsTPS\n *\n * This class serves as the Transaction Processing System. Note that it manages\n * a stack of jsTPS_Transaction objects, each of which know how to do or undo\n * state changes for the given application. Note that this TPS is not platform\n * specific as it is programmed in raw JavaScript.\n */\n\nexport default class jsTPS {\n  constructor() {\n    // THE TRANSACTION STACK\n    this.transactions = []; // THE TOTAL NUMBER OF TRANSACTIONS ON THE STACK,\n    // INCLUDING THOSE THAT MAY HAVE ALREADY BEEN UNDONE\n\n    this.numTransactions = 0; // THE INDEX OF THE MOST RECENT TRANSACTION, NOTE THAT\n    // THIS MAY BE IN THE MIDDLE OF THE TRANSACTION STACK\n    // IF SOME TRANSACTIONS ON THE STACK HAVE BEEN UNDONE\n    // AND STILL COULD BE REDONE.\n\n    this.mostRecentTransaction = -1; // THESE STATE VARIABLES ARE TURNED ON AND OFF WHILE\n    // TRANSACTIONS ARE DOING THEIR WORK SO AS TO HELP\n    // MANAGE CONCURRENT UPDATES\n\n    this.performingDo = false;\n    this.performingUndo = false;\n  }\n  /**\n   * isPerformingDo\n   *\n   * Accessor method for getting a boolean representing whether or not\n   * a transaction is currently in the midst of a do/redo operation.\n   */\n\n\n  isPerformingDo() {\n    return this.performingDo;\n  }\n  /**\n   * isPerformingUndo\n   *\n   * Accessor method for getting a boolean representing whether or not\n   * a transaction is currently in the midst of an undo operation.\n   */\n\n\n  isPerformingUndo() {\n    return this.performingUndo;\n  }\n  /**\n   * getSize\n   *\n   * Accessor method for getting the number of transactions on the stack.\n   */\n\n\n  getSize() {\n    return this.transactions.length;\n  }\n  /**\n   * getRedoSize\n   *\n   * Method for getting the total number of transactions on the stack\n   * that can possibly be redone.\n   */\n\n\n  getRedoSize() {\n    return this.getSize() - this.mostRecentTransaction - 1;\n  }\n  /**\n   * getUndoSize\n   *\n   * Method for getting the total number of transactions on the stack\n   * that can possible be undone.\n   */\n\n\n  getUndoSize() {\n    return this.mostRecentTransaction + 1;\n  }\n  /**\n   * hasTransactionToRedo\n   *\n   * Method for getting a boolean representing whether or not\n   * there are transactions on the stack that can be redone.\n   */\n\n\n  hasTransactionToRedo() {\n    return this.mostRecentTransaction + 1 < this.numTransactions;\n  }\n  /**\n   * hasTransactionToUndo\n   *\n   * Method for getting a boolean representing whehter or not\n   * there are transactions on the stack that can be undone.\n   */\n\n\n  hasTransactionToUndo() {\n    return this.mostRecentTransaction >= 0;\n  }\n  /**\n   * addTransaction\n   *\n   * Method for adding a transaction to the TPS stack, note it\n   * also then does the transaction.\n   *\n   * @param {jsTPS_Transaction} transaction Transaction to add to the stack and do.\n   */\n\n\n  addTransaction(transaction) {\n    // ARE WE BRANCHING?\n    if (this.mostRecentTransaction < 0 || this.mostRecentTransaction < this.transactions.length - 1) {\n      for (let i = this.transactions.length - 1; i > this.mostRecentTransaction; i--) {\n        this.transactions.splice(i, 1);\n      }\n\n      this.numTransactions = this.mostRecentTransaction + 2;\n    } else {\n      this.numTransactions++;\n    } // ADD THE TRANSACTION\n\n\n    this.transactions[this.mostRecentTransaction + 1] = transaction; // AND EXECUTE IT\n\n    this.doTransaction();\n  }\n  /**\n   * doTransaction\n   *\n   * Does the current transaction on the stack and advances the transaction\n   * counter. Note this function may be invoked as a result of either adding\n   * a transaction (which also does it), or redoing a transaction.\n   */\n\n\n  doTransaction() {\n    if (this.hasTransactionToRedo()) {\n      this.performingDo = true;\n      let transaction = this.transactions[this.mostRecentTransaction + 1];\n      transaction.doTransaction();\n      this.mostRecentTransaction++;\n      this.performingDo = false;\n    } // ! Call the other two methods after a transaction is done\n\n\n    this.enableOrDisableRedoButton();\n    this.enableOrDisableUndoButton();\n  }\n  /**\n   * This function gets the most recently executed transaction on the\n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n\n\n  undoTransaction() {\n    if (this.hasTransactionToUndo()) {\n      this.performingUndo = true;\n      let transaction = this.transactions[this.mostRecentTransaction];\n      transaction.undoTransaction();\n      this.mostRecentTransaction--;\n      this.performingUndo = false;\n    } // ! Call the other two methods after a transaction is done\n\n\n    this.enableOrDisableRedoButton();\n    this.enableOrDisableUndoButton();\n  } // ! FULLPROOFING - DISABLES OR ENABLES THE BUTTONS IF THE STACK HAS THINGS TO UNDEO / REDO\n\n\n  enableOrDisableRedoButton() {\n    const button = document.getElementById(\"redo-button\");\n\n    if (this.hasTransactionToRedo()) {\n      button.disabled = false;\n    } else {\n      button.disabled = true;\n    }\n  } // ! FULLPROOFING - DISABLES OR ENABLES THE BUTTONS IF THE STACK HAS THINGS TO UNDEO / REDO\n\n\n  enableOrDisableUndoButton() {\n    const button = document.getElementById(\"undo-button\");\n\n    if (this.hasTransactionToUndo()) {\n      button.disabled = false;\n    } else {\n      button.disabled = true;\n    }\n  }\n  /**\n   * clearAllTransactions\n   *\n   * Removes all the transactions from the TPS, leaving it with none.\n   */\n\n\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = []; // MAKE SURE TO RESET THE LOCATION OF THE\n    // TOP OF THE TPS STACK TOO\n\n    this.mostRecentTransaction = -1;\n    this.numTransactions = 0;\n  }\n  /**\n   * toString\n   *\n   * Builds and returns a textual represention of the full TPS and its stack.\n   */\n\n\n  toString() {\n    let text = \"--Number of Transactions: \" + this.numTransactions + \"\\n\";\n    text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"\\n\";\n    text += \"--Current Transaction Stack:\\n\";\n\n    for (let i = 0; i <= this.mostRecentTransaction; i++) {\n      let jT = this.transactions[i];\n      text += \"----\" + jT.toString() + \"\\n\";\n    }\n\n    return text;\n  }\n\n}","map":{"version":3,"names":["jsTPS_Transaction","doTransaction","console","log","undoTransaction","jsTPS","constructor","transactions","numTransactions","mostRecentTransaction","performingDo","performingUndo","isPerformingDo","isPerformingUndo","getSize","length","getRedoSize","getUndoSize","hasTransactionToRedo","hasTransactionToUndo","addTransaction","transaction","i","splice","enableOrDisableRedoButton","enableOrDisableUndoButton","button","document","getElementById","disabled","clearAllTransactions","toString","text","jT"],"sources":["C:/Users/Sebastian Valdez/Documents/CSE 316 Homeworks/Homework 3/Playlister_HW3-main/client/src/common/jsTPS.js"],"sourcesContent":["/**\n * jsTPS_Transaction\n *\n * This provides the basic structure for a transaction class. Note to use\n * jsTPS one should create objects that define these two methods, doTransaction\n * and undoTransaction, which will update the application state accordingly.\n *\n * @author THE McKilla Gorilla (accept no imposters)\n * @version 1.0\n */\nexport class jsTPS_Transaction {\n  /**\n   * This method is called by jTPS when a transaction is executed.\n   */\n  doTransaction() {\n    console.log(\"doTransaction - MISSING IMPLEMENTATION\");\n  }\n\n  /**\n   * This method is called by jTPS when a transaction is undone.\n   */\n  undoTransaction() {\n    console.log(\"undoTransaction - MISSING IMPLEMENTATION\");\n  }\n}\n\n/**\n * jsTPS\n *\n * This class serves as the Transaction Processing System. Note that it manages\n * a stack of jsTPS_Transaction objects, each of which know how to do or undo\n * state changes for the given application. Note that this TPS is not platform\n * specific as it is programmed in raw JavaScript.\n */\nexport default class jsTPS {\n  constructor() {\n    // THE TRANSACTION STACK\n    this.transactions = [];\n\n    // THE TOTAL NUMBER OF TRANSACTIONS ON THE STACK,\n    // INCLUDING THOSE THAT MAY HAVE ALREADY BEEN UNDONE\n    this.numTransactions = 0;\n\n    // THE INDEX OF THE MOST RECENT TRANSACTION, NOTE THAT\n    // THIS MAY BE IN THE MIDDLE OF THE TRANSACTION STACK\n    // IF SOME TRANSACTIONS ON THE STACK HAVE BEEN UNDONE\n    // AND STILL COULD BE REDONE.\n    this.mostRecentTransaction = -1;\n\n    // THESE STATE VARIABLES ARE TURNED ON AND OFF WHILE\n    // TRANSACTIONS ARE DOING THEIR WORK SO AS TO HELP\n    // MANAGE CONCURRENT UPDATES\n    this.performingDo = false;\n    this.performingUndo = false;\n  }\n\n  /**\n   * isPerformingDo\n   *\n   * Accessor method for getting a boolean representing whether or not\n   * a transaction is currently in the midst of a do/redo operation.\n   */\n  isPerformingDo() {\n    return this.performingDo;\n  }\n\n  /**\n   * isPerformingUndo\n   *\n   * Accessor method for getting a boolean representing whether or not\n   * a transaction is currently in the midst of an undo operation.\n   */\n  isPerformingUndo() {\n    return this.performingUndo;\n  }\n\n  /**\n   * getSize\n   *\n   * Accessor method for getting the number of transactions on the stack.\n   */\n  getSize() {\n    return this.transactions.length;\n  }\n\n  /**\n   * getRedoSize\n   *\n   * Method for getting the total number of transactions on the stack\n   * that can possibly be redone.\n   */\n  getRedoSize() {\n    return this.getSize() - this.mostRecentTransaction - 1;\n  }\n\n  /**\n   * getUndoSize\n   *\n   * Method for getting the total number of transactions on the stack\n   * that can possible be undone.\n   */\n  getUndoSize() {\n    return this.mostRecentTransaction + 1;\n  }\n\n  /**\n   * hasTransactionToRedo\n   *\n   * Method for getting a boolean representing whether or not\n   * there are transactions on the stack that can be redone.\n   */\n  hasTransactionToRedo() {\n    return this.mostRecentTransaction + 1 < this.numTransactions;\n  }\n\n  /**\n   * hasTransactionToUndo\n   *\n   * Method for getting a boolean representing whehter or not\n   * there are transactions on the stack that can be undone.\n   */\n  hasTransactionToUndo() {\n    return this.mostRecentTransaction >= 0;\n  }\n\n  /**\n   * addTransaction\n   *\n   * Method for adding a transaction to the TPS stack, note it\n   * also then does the transaction.\n   *\n   * @param {jsTPS_Transaction} transaction Transaction to add to the stack and do.\n   */\n  addTransaction(transaction) {\n    // ARE WE BRANCHING?\n    if (\n      this.mostRecentTransaction < 0 ||\n      this.mostRecentTransaction < this.transactions.length - 1\n    ) {\n      for (\n        let i = this.transactions.length - 1;\n        i > this.mostRecentTransaction;\n        i--\n      ) {\n        this.transactions.splice(i, 1);\n      }\n      this.numTransactions = this.mostRecentTransaction + 2;\n    } else {\n      this.numTransactions++;\n    }\n\n    // ADD THE TRANSACTION\n    this.transactions[this.mostRecentTransaction + 1] = transaction;\n\n    // AND EXECUTE IT\n    this.doTransaction();\n  }\n\n  /**\n   * doTransaction\n   *\n   * Does the current transaction on the stack and advances the transaction\n   * counter. Note this function may be invoked as a result of either adding\n   * a transaction (which also does it), or redoing a transaction.\n   */\n  doTransaction() {\n    if (this.hasTransactionToRedo()) {\n      this.performingDo = true;\n      let transaction = this.transactions[this.mostRecentTransaction + 1];\n      transaction.doTransaction();\n      this.mostRecentTransaction++;\n      this.performingDo = false;\n    }\n\n    // ! Call the other two methods after a transaction is done\n    this.enableOrDisableRedoButton();\n    this.enableOrDisableUndoButton();\n  }\n\n  /**\n   * This function gets the most recently executed transaction on the\n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n  undoTransaction() {\n    if (this.hasTransactionToUndo()) {\n      this.performingUndo = true;\n      let transaction = this.transactions[this.mostRecentTransaction];\n      transaction.undoTransaction();\n      this.mostRecentTransaction--;\n      this.performingUndo = false;\n    }\n\n    // ! Call the other two methods after a transaction is done\n    this.enableOrDisableRedoButton();\n    this.enableOrDisableUndoButton();\n  }\n\n  // ! FULLPROOFING - DISABLES OR ENABLES THE BUTTONS IF THE STACK HAS THINGS TO UNDEO / REDO\n  enableOrDisableRedoButton() {\n    const button = document.getElementById(\"redo-button\");\n    if (this.hasTransactionToRedo()) {\n      button.disabled = false;\n    } else {\n      button.disabled = true;\n    }\n  }\n\n  // ! FULLPROOFING - DISABLES OR ENABLES THE BUTTONS IF THE STACK HAS THINGS TO UNDEO / REDO\n  enableOrDisableUndoButton() {\n    const button = document.getElementById(\"undo-button\");\n    if (this.hasTransactionToUndo()) {\n      button.disabled = false;\n    } else {\n      button.disabled = true;\n    }\n  }\n\n  /**\n   * clearAllTransactions\n   *\n   * Removes all the transactions from the TPS, leaving it with none.\n   */\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = [];\n\n    // MAKE SURE TO RESET THE LOCATION OF THE\n    // TOP OF THE TPS STACK TOO\n    this.mostRecentTransaction = -1;\n    this.numTransactions = 0;\n  }\n\n  /**\n   * toString\n   *\n   * Builds and returns a textual represention of the full TPS and its stack.\n   */\n  toString() {\n    let text = \"--Number of Transactions: \" + this.numTransactions + \"\\n\";\n    text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"\\n\";\n    text += \"--Current Transaction Stack:\\n\";\n    for (let i = 0; i <= this.mostRecentTransaction; i++) {\n      let jT = this.transactions[i];\n      text += \"----\" + jT.toString() + \"\\n\";\n    }\n    return text;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,iBAAN,CAAwB;EAC7B;AACF;AACA;EACEC,aAAa,GAAG;IACdC,OAAO,CAACC,GAAR,CAAY,wCAAZ;EACD;EAED;AACF;AACA;;;EACEC,eAAe,GAAG;IAChBF,OAAO,CAACC,GAAR,CAAY,0CAAZ;EACD;;AAb4B;AAgB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAME,KAAN,CAAY;EACzBC,WAAW,GAAG;IACZ;IACA,KAAKC,YAAL,GAAoB,EAApB,CAFY,CAIZ;IACA;;IACA,KAAKC,eAAL,GAAuB,CAAvB,CANY,CAQZ;IACA;IACA;IACA;;IACA,KAAKC,qBAAL,GAA6B,CAAC,CAA9B,CAZY,CAcZ;IACA;IACA;;IACA,KAAKC,YAAL,GAAoB,KAApB;IACA,KAAKC,cAAL,GAAsB,KAAtB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,cAAc,GAAG;IACf,OAAO,KAAKF,YAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEG,gBAAgB,GAAG;IACjB,OAAO,KAAKF,cAAZ;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEG,OAAO,GAAG;IACR,OAAO,KAAKP,YAAL,CAAkBQ,MAAzB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,WAAW,GAAG;IACZ,OAAO,KAAKF,OAAL,KAAiB,KAAKL,qBAAtB,GAA8C,CAArD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEQ,WAAW,GAAG;IACZ,OAAO,KAAKR,qBAAL,GAA6B,CAApC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACES,oBAAoB,GAAG;IACrB,OAAO,KAAKT,qBAAL,GAA6B,CAA7B,GAAiC,KAAKD,eAA7C;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEW,oBAAoB,GAAG;IACrB,OAAO,KAAKV,qBAAL,IAA8B,CAArC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAC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"},"metadata":{},"sourceType":"module"}